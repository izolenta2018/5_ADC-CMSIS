
//тренировочная программа для атмега8 
//фузбиты: 
//CKSEL0=0 
//CKSEL1=0
//CKSEL2=1
//CKSEL3=0
//SUT0=0
//SUT1=0
//BODEN=0 (on)
//BODLEVEL=0 (on)
//BOOTRST=1 (off)
//BOOTSZ0=1 (off)
//BOOTSZ1=1 (off) 
//EESAVE=1 (off)
//CKOPT=1 (off)
//WDTON=1 (off)
//RSTDISBL=1 (off)


//   0    1    2    3    4     5     6    7     8    9    // для порта D
// 0x50 0x5f 0x31 0x15 0x1e  0x94  0x90 0x5d  0x10 0x14

#include <mega8.h>
#include <DELAY.h>
#define beep_on PORTB.4 = 0;
#define beep_off PORTB.4 = 1;
#define ADC_VREF_TYPE 0x00

unsigned char dig[5]=
{
0b11011111, //dig1 старший
0b11101111, //dig2
0b11110111, //dig3
0b11111011, //dig4
0b11111101 //dig5
};

unsigned char symbol[10] = 
{
  0x50, //0
  0x5f, //1
  0x31, //2
  0x15, //3   
  0x1e, //4
  0x94, //5 
  0x90, //6
  0x5d, //7   
  0x10, //8
  0x14  //9    
};

unsigned int g,T,x=0,a;
unsigned int n[5];      // массив из цифр разложенного числа

      
void main( void )
{
  
PORTC = 0x00;      //гасим цифры
PORTD = 0x00;      //гасим сегменты
PORTB = 0b00111000;       // подтягиваем резистор к кнопке SA_2

DDRC = 0xfe;//   на вход PC0
DDRD = 0xff;//   на выход
DDRB = 0b00010000;//     на вход PB3,PB5

beep_off;





//ADCSRA=0b11000110; 
 


TCCR0 = 0x03;                         // настраиваем делитель на 64 (частота ТС 125кГц)

   while(1)                                 // вечный цикл
 { 
                                                              
     while((TIFR & 0b00000001)==0);         // ожидание переполнения, пока ТС не станет =0 логическому, время счета 2 мс
     TCNT0 = 6;                              // выставляем начальное значение таймера TCNT0
     TIFR |= 0x01;                          // сброс флага таймера0. Обязательно надо записывать 1, чтобы сбросить флаг в 0!!!!

  
   if ((ADCSRA & 0b00010000)==16)           // ждем ADIF=0
   {
   T=4.8876*ADCW;
   } 
   ADMUX=0b01000000;
   
   ADCSRA=0b11010110;    
    
    //дв.-дес. преобразование:   //27748
a=T/10000;        //2
n[0]=symbol[a];   //двоичный вид цифры 2
T%=10000;         //7748

a=T/1000;        //7
n[1]=symbol[a];  //двоичный вид цифры 7
T%=1000;         //748

a=T/100;        //7
n[2]=symbol[a]; //двоичный вид цифры 7
T%=100;         //48

a=T/10;         //4
n[3]=symbol[a]; //двоичный вид цифры 4

a=T%10;         //8
n[4]=symbol[a]; //двоичный вид цифры 8

    

     
    
    PORTC |= 0b00111110;      // назначение нужного разряда
    PORTD = 0xff;
     
    PORTD = n[x];        // вывод нужных сегментов  
    PORTC &= dig[x];      // назначение нужного разряда
             
    ++x;        
    if (x>4)  
    {
    x=0; 
      
    }       
   }
 }  
